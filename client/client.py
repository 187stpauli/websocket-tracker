from functools import wraps
from aiohttp import ClientHttpProxyError
from web3.middleware.geth_poa import async_geth_poa_middleware
from web3.exceptions import TransactionNotFound
from web3 import AsyncWeb3
from web3.providers.websocket import WebsocketProviderV2
from web3.contract import AsyncContract
from typing import Optional, Union
from web3.types import TxParams
from hexbytes import HexBytes
from client.networks import Network
import asyncio
import logging
import json

with open("abi/erc20_abi.json", "r", encoding="utf-8") as file:
    ERC20_ABI = json.load(file)

logger = logging.getLogger(__name__)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[logging.StreamHandler()]
)


def retry_on_proxy_error(max_attempts: int = 3, fallback_no_proxy: bool = True):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö –ø—Ä–æ–∫—Å–∏."""

    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            attempts = 0
            last_error = None
            while attempts < max_attempts:
                try:
                    return await func(self, *args, **kwargs)
                except ClientHttpProxyError as e:
                    attempts += 1
                    last_error = e
                    logger.warning(f"üßπ –û—à–∏–±–∫–∞ –ø—Ä–æ–∫—Å–∏ (–ø–æ–ø—ã—Ç–∫–∞ {attempts}/{max_attempts}): {e}")
                    if attempts == max_attempts and fallback_no_proxy:
                        logger.info("–û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–æ–∫—Å–∏ –¥–ª—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –ø–æ–ø—ã—Ç–∫–∏")
                        self._disable_proxy()
                        try:
                            return await func(self, *args, **kwargs)
                        except ClientHttpProxyError as e:
                            last_error = e
                    await asyncio.sleep(1)
            raise ValueError(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –ø–æ—Å–ª–µ {max_attempts} –ø–æ–ø—ã—Ç–æ–∫: {last_error}")

        return wrapper

    return decorator


class Client:
    def __init__(self, chain_id: int, rpc_url: str, explorer_url: str, token1: str, token2: str,
                 proxy: Optional[str] = None, private_key: Optional[str] = None):
        request_kwargs = {"proxy": f"http://{proxy}"} if proxy else {}

        self.explorer_url = explorer_url
        self.chain_id = chain_id
        self.token1 = token1
        self.token2 = token2
        self.rpc_url = rpc_url
        self.proxy = proxy

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–µ—Ç—å
        if isinstance(chain_id, str):
            self.network = Network.from_name(chain_id)
        else:
            self.network = Network.from_chain_id(chain_id)

        self.chain_id = self.network.chain_id

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è AsyncWeb3
        self.w3 = AsyncWeb3(WebsocketProviderV2(rpc_url, websocket_kwargs=request_kwargs))
        # –ü—Ä–∏–º–µ–Ω—è–µ–º middleware –¥–ª—è PoA-—Å–µ—Ç–µ–π
        if self.network.is_poa:
            self.w3.middleware_onion.clear()
            self.w3.middleware_onion.inject(async_geth_poa_middleware, layer=0)

        self.eip_1559 = True

    async def set_amount(self, real_amount: int):
        self.amount = real_amount

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –Ω–∞—Ç–∏–≤–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞
    async def get_native_balance(self) -> float:
        """–ü–æ–ª—É—á–∞–µ—Ç –±–∞–ª–∞–Ω—Å –Ω–∞—Ç–∏–≤–Ω–æ–≥–æ —Ç–æ–∫–µ–Ω–∞ –≤ ETH/BNB/MATIC –∏ —Ç.–¥."""
        balance_wei = await self.w3.eth.get_balance(self.address)
        return balance_wei

    # –ü–æ–ª—É—á–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ ERC20
    async def get_erc20_balance(self, address: str) -> float | int:

        contract = self.w3.eth.contract(
            address=self.w3.to_checksum_address(address), abi=ERC20_ABI)
        try:
            balance = await contract.functions.balanceOf(self.address).call()
            return balance
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∞–ª–∞–Ω—Å–∞ ERC20: {e}")
            return 0

    async def get_allowance(self, token_address: str, owner: str, spender: str) -> int:
        try:
            contract = await self.get_contract(token_address, ERC20_ABI)
            allowance = await contract.functions.allowance(
                self.w3.to_checksum_address(owner),
                self.w3.to_checksum_address(spender)
            ).call()
            return allowance
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ allowance: {e}")
            return 0

    # –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ –∫–æ–Ω—Ç—Ä–∞–∫—Ç –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –æ–±—Ä–∞—â–µ–Ω–∏—è –∫ –Ω–µ–º—É
    async def get_contract(self, contract_address: str, abi: list) -> AsyncContract:
        return self.w3.eth.contract(
            address=self.w3.to_checksum_address(contract_address), abi=abi
        )

    # –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—É–º–º—ã –≥–∞–∑–∞ –∑–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é
    async def get_tx_fee(self) -> int:
        try:
            fee_history = await self.w3.eth.fee_history(10, "latest", [50])
            base_fee = fee_history['baseFeePerGas'][-1]
            max_priority_fee = await self.w3.eth.max_priority_fee
            estimated_gas = 70_000
            max_fee_per_gas = (base_fee + max_priority_fee) * estimated_gas

            return max_fee_per_gas
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á—ë—Ç–µ –∫–æ–º–∏—Å—Å–∏–∏, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback: {e}")
            fallback_gas_price = await self.w3.eth.gas_price
            return fallback_gas_price * 70_000

    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ –≤–µ–∏
    async def to_wei_main(self, number: int | float, token_address: Optional[str] = None):
        if token_address:
            contract = await self.get_contract(token_address, ERC20_ABI)
            decimals = await contract.functions.decimals().call()
        else:
            decimals = 18

        unit_name = {
            6: "mwei",
            9: "gwei",
            18: "ether"
        }.get(decimals)

        if not unit_name:
            raise RuntimeError(f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –∏–º—è —é–Ω–∏—Ç–∞ —Å –¥–µ—Ü–∏–º–∞–ª–∞–º–∏: {decimals}")
        return self.w3.to_wei(number, unit_name)

    # –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∏–∑ –≤–µ–∏
    async def from_wei_main(self, number: int | float, token_address: Optional[str] = None):
        if token_address:
            contract = await self.get_contract(token_address, ERC20_ABI)
            decimals = await contract.functions.decimals().call()
        else:
            decimals = 18

        unit_name = {
            6: "mwei",
            9: "gwei",
            18: "ether"
        }.get(decimals)

        if not unit_name:
            raise RuntimeError(f"–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ –∏–º—è —é–Ω–∏—Ç–∞ —Å –¥–µ—Ü–∏–º–∞–ª–∞–º–∏: {decimals}")
        return self.w3.from_wei(number, unit_name)

    # Approve
    async def approve_usdc(self, usdc_address, spender, amount, eip_1559: bool):
        contract = await self.get_contract(usdc_address, ERC20_ABI)
        owner = self.address
        nonce = await self.w3.eth.get_transaction_count(owner)
        chain_id = await self.w3.eth.chain_id

        tx_params = {
            'from': owner,
            'nonce': nonce,
            'gas': 300_000,
            'chainId': chain_id
        }

        if eip_1559:
            base_fee = await self.w3.eth.gas_price
            max_priority_fee = int(base_fee * 0.1) or 1_000_000  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —á–∞–µ–≤–∞—è
            max_fee = int(base_fee * 1.5 + max_priority_fee)

            tx_params.update({
                'maxPriorityFeePerGas': max_priority_fee,
                'maxFeePerGas': max_fee,
                'type': '0x2'
            })
        else:
            tx_params['gasPrice'] = int(await self.w3.eth.gas_price * 1.25)

        # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ approve
        tx = await contract.functions.approve(spender, amount).build_transaction(tx_params)

        # –ü–æ–¥–ø–∏—Å—å –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞
        signed_tx = self.w3.eth.account.sign_transaction(tx, self.private_key)
        tx_hash = await self.w3.eth.send_raw_transaction(signed_tx.raw_transaction)
        receipt = await self.w3.eth.wait_for_transaction_receipt(tx_hash)

        return receipt

    # –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    async def prepare_tx(self, value: Union[int, float] = 0) -> TxParams:
        transaction: TxParams = {
            "chainId": await self.w3.eth.chain_id,
            "nonce": await self.w3.eth.get_transaction_count(self.address),
            "from": self.address,
            "value": value,
        }

        if self.eip_1559:
            base_fee = await self.w3.eth.gas_price
            max_priority_fee_per_gas = await self.w3.eth.max_priority_fee or base_fee
            max_fee_per_gas = int(base_fee * 1.25 + max_priority_fee_per_gas)

            transaction.update({
                "maxPriorityFeePerGas": max_priority_fee_per_gas,
                "maxFeePerGas": max_fee_per_gas,
                "type": "0x2",
            })
        else:
            transaction["gasPrice"] = int((await self.w3.eth.gas_price) * 1.25)

        return transaction

    # –ü–æ–¥–ø–∏—Å—å –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    async def sign_and_send_tx(self, transaction: TxParams, without_gas: bool = False,
                               external_gas: Optional[int] = None):
        try:

            if not without_gas:
                if external_gas:
                    transaction["gas"] = int(external_gas * 1.5)
                else:
                    transaction["gas"] = int((await self.w3.eth.estimate_gas(transaction)) * 1.5)
            nonce = await self.w3.eth.get_transaction_count(self.address)
            transaction['nonce'] = nonce
            signed = self.w3.eth.account.sign_transaction(transaction, self.private_key)
            signed_raw_tx = signed.raw_transaction
            logger.info("‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –ø–æ–¥–ø–∏—Å–∞–Ω–∞\n")

            tx_hash_bytes = await self.w3.eth.send_raw_transaction(signed_raw_tx)
            tx_hash_hex = self.w3.to_hex(tx_hash_bytes)
            logger.info("‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞: %s\n", tx_hash_hex)

            return tx_hash_hex
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏: {e}")
            return None

    # –û–∂–∏–¥–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    async def wait_tx(self, tx_hash: Union[str, HexBytes], explorer_url: Optional[str] = None) -> bool:
        total_time = 0
        timeout = 120
        poll_latency = 10

        tx_hash_bytes = HexBytes(tx_hash)  # –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ HexBytes

        while True:
            try:
                receipt = await self.w3.eth.get_transaction_receipt(tx_hash_bytes)
                status = receipt.get("status")
                if status == 1:
                    logger.info(f"‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ: {explorer_url}/tx/{tx_hash_bytes.hex()}\n")
                    return True
                elif status is None:
                    await asyncio.sleep(poll_latency)
                else:
                    logger.error(f"‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: {explorer_url}/tx/{tx_hash_bytes.hex()}")
                    return False
            except TransactionNotFound:
                if total_time > timeout:
                    logger.warning(f"‚ùå –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è {tx_hash_bytes.hex()} –Ω–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª–∞—Å—å –∑–∞ 120 —Å–µ–∫—É–Ω–¥")
                    return False
                total_time += poll_latency
                await asyncio.sleep(poll_latency)
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ receipt: {e}")
                return False
